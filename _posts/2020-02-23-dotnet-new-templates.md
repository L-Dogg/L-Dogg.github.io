---
layout: post
title: Using dotnet new templates to streamline microservices development
#subtitle:
bigimg: /img/rocket_50.jpg
tags: [dotnet, template, microservices]
---

# What's that and why would I want to use it?
When working on a project consisting of numerous microservices, you often find that each service share a part of "common" code. This becomes a burdensome copy-paste activity when you have to add one more microservices. There are some straightforward and not-so-clean solutions to this problem (i.e. copying from a microservice of a colleague who read "Clean Code" or maintains an exemplary service). In this post, however, I'd like to explore another option suitable for dotnet core developers: `dotnet new` templates.

When you type `dotnet new` in your terminal, you get a rather large list of predefined solutions, webapi, mvc or console being the most noted. But did you know that you can create your own template that can be used for example by your open source project's users or your teammates?  

As I stated before, there's (well, at least one) common and frequent headache when working with microservices: lots of boilerplate code copy-pasta when adding a new shiny microservice to the existing gang. But, lo and behold, there's a simple solution that's shipped with the SDK: custom dotnet new templates to the rescue!  
## Factor out common code
You can easily standarize a lot of boilerplate code with a custom `dotnet new` template. Let's take a look at standard WebAPI project files: `Startup.cs` and `Program.cs`. While first is usually changed (and the changes are most likely incremental IoC container registrations etc.), the second one usally stays untouched once someones configures a HostBuilder. So why don't we factor out the common code: loading configuration, setting up service to service auth, serialization settings, as well as configuring logging, health checks, swagger or any bootstrappers you may want. This way virtually no one can can create an unstandarized service that doesn't expose specification or cannot deserialize messages from other parts of the system. Almost all configuration comes out of the box.

## Enforce consistent code style and solution structure 
Moreover, custom `dotnet new` template might be also a good way to nudge the team to keep your services' solutions structured in the same way across all repos and that may come in handy by reducing the cognitive overhead when you'll find yourself looking for a bug in your mate's service's code. Other than that, onboarding a new teammate may be a bit easier if he has a simple microservice MVP that he can dive into to see an example of your development standards. Hence, adding unit and integration tests do the template is really worth considering. Such a template after some discussions and development would become a source of truth for the project's code style.

## Set rules for dependency and tooling management
Instituting common tooling is way easier now with the `dotnet tool` command. And you can store tools' desired versions in the `dotnet-tools.json` and include it in the template. Same goes without saying for referenced packages &mdash; you can settle for a specific version of given nuget and enforce it by shipping it locked in your dependency manager (hello, [paket](https://fsprojects.github.io/Paket/index.html)!) with your template.  
You can also deliver your template with build or deployment scripts for your microservice as well as a minimal dockerfile &mdash; just enough to build it, test it and deploy it somewhere.

# Nuts-and-bolts
When it comes to creating a `dotnet new` template there aren't many traps or catches - the process is rather straightforward and well documented. Just create a new dotnet project, add some config files and voila! The most important files are `template.json` and `dotnetcli-host.json`. Using the first one can describe his template via some metadata and specify parameters. For example, you can create C# project called *ServiceTemplate* and use this config to replace this string everywhere (including filenames) with a flag passed from the CLI:
```
"symbols":
{
    "serviceName": 
    {
        "type": "parameter",
        "datatype": "text",
        "replaces": "ServiceTemplate",
        "isRequired": true,
        "description": "Name of the service",
        "FileRename": "ServiceTemplate"
    }
}
```
`template.json` schema has a really in-depth docs that can be found on [GitHub](https://github.com/dotnet/templating/wiki/Reference-for-template.json).  
`dotnetcli-host.json` allows you to specify a shortcut for your command options (the ones generated by the template engine can sometimes be confusing).
```
"symbolInfo": 
{
    "serviceName": 
    {
    "longName": "service-name",
    "shortName": "sn"
    }
}
```
Another useful feature is testing &mdash; you can examine the execution of arbitrary code ran by the template, check for existence of generated files and directories or even make a request to a running service and assert the response code.  
After you test your project, it can be installed from a directory or a nuget via `dotnet new -i` command.

Although they aren't a silver bullet, I find `dotnet new` custom templates very useful in day-to-day work. [Read the docs](https://docs.microsoft.com/en-us/dotnet/core/tools/custom-templates) and try them yourself &mdash; it's really worth the (rather low) effort.